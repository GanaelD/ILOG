'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('xstate/lib/utils');
var machineExtractor = require('@xstate/machine-extractor');
var xstate = require('xstate');
var fs = require('fs/promises');
var path = require('path');
var prettier = require('prettier');

function _interopNamespace(e) {
	if (e && e.__esModule) return e;
	var n = Object.create(null);
	if (e) {
		Object.keys(e).forEach(function (k) {
			if (k !== 'default') {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () {
						return e[k];
					}
				});
			}
		});
	}
	n['default'] = e;
	return Object.freeze(n);
}

var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var path__namespace = /*#__PURE__*/_interopNamespace(path);
var prettier__namespace = /*#__PURE__*/_interopNamespace(prettier);

const getTransitionsFromNode = node => {
  const transitions = new Set();

  if (node.parent) {
    Object.keys(node.parent.states).forEach(key => transitions.add(key));
    Object.values(node.parent.states).forEach(siblingNode => {
      getMatchesStates(siblingNode).forEach(key => {
        if (key === siblingNode.path.join('.')) {
          return;
        }

        let relativeKey = key;

        if ((node.parent?.path.length || 0) > 0) {
          relativeKey = relativeKey.replace(new RegExp(`^${node.parent.path.join('.')}\.`), '');
        }

        transitions.add(relativeKey);
      });
    });
  }

  Object.values(node.states).map(childNode => {
    getMatchesStates(childNode).map(key => {
      let relativeKey = key;

      if ((childNode.parent?.path.length || 0) > 0) {
        relativeKey = relativeKey.replace(new RegExp(`^${childNode.parent.path.join('.')}\.`), '');
      }

      transitions.add(`.${relativeKey}`);
      transitions.add(`${relativeKey}`);
    });
  });
  const rootNode = getRootNode(node);
  const nodesWithId = rootNode.stateIds.filter(id => !/(\.|\(machine\))/.test(id)).map(id => rootNode.getStateNodeById(id));
  nodesWithId.forEach(idNode => {
    getMatchesStates(idNode).forEach(match => {
      if (idNode.id === rootNode.id) {
        transitions.add(`#${idNode.id}.${match}`);
        return;
      }

      transitions.add(match.replace(new RegExp(`^${idNode.path.join('.')}`), `#${idNode.id}`));
    });
  });
  utils.toStatePaths(utils.pathToStateValue(node.path)).forEach(path => {
    if (path.length > 1) {
      transitions.delete(path.join('.'));
    }
  });
  return Array.from(transitions);
};
const getMatchesStates = machine => {
  const allStateNodes = machine.stateIds.map(id => machine.getStateNodeById(id));
  const states = allStateNodes.reduce((arr, node) => {
    return [...arr, ...utils.toStatePaths(utils.pathToStateValue(node.path)).map(path => path.join('.'))];
  }, []);
  return states;
};
const getRootNode = node => {
  if (!node.parent) {
    return node;
  }

  return getRootNode(node.parent);
};

const makeSubStateFromNode = (node, rootNode, nodeMaps) => {
  const nodeFromMap = nodeMaps[node.id];
  const stateNode = rootNode.getStateNodeById(node.id);
  const targets = getTransitionsFromNode(stateNode);
  return {
    sources: Array.from(nodeFromMap.sources).filter(Boolean),
    targets: targets.filter(Boolean),
    states: Array.from(nodeFromMap.children).reduce((obj, child) => {
      const childNode = rootNode.getStateNodeById(child);
      return { ...obj,
        [childNode.key]: makeSubStateFromNode(childNode, rootNode, nodeMaps)
      };
    }, {})
  };
};

class ItemMap {
  /**
   * The internal map that we use to keep track
   * of all of the items
   */

  /**
   * Check if one of these items is optional -
   * passed in from above via a prop
   */
  constructor(props) {
    this.checkIfOptional = props.checkIfOptional;
    this.map = {};
  }
  /**
   * Add an item to the cache, along with the path of the node
   * it occurs on
   */


  addItem(itemName, nodePath) {
    if (!this.map[itemName]) {
      this.map[itemName] = {
        events: new Set(),
        states: new Set()
      };
    }

    this.map[itemName].states.add(utils.pathToStateValue(nodePath));
  }
  /**
   * Add a triggering event to an item in the cache, for
   * instance the event type which triggers a guard/action/service
   */


  addEventToItem(itemName, eventType, nodePath) {
    this.addItem(itemName, nodePath);
    this.map[itemName].events.add(eventType);
  }
  /**
   * Transform the data into the shape required for index.d.ts
   */


  toDataShape() {
    let isRequiredInTotal = false;
    const lines = Object.entries(this.map).filter(([name]) => {
      return !(name === machineExtractor.INLINE_IMPLEMENTATION_TYPE);
    }).map(([name, data]) => {
      const optional = this.checkIfOptional(name);

      if (!optional) {
        isRequiredInTotal = true;
      }

      return {
        name,
        required: !optional,
        events: Array.from(data.events),
        states: Array.from(data.states).map(state => JSON.stringify(state)).filter(Boolean)
      };
    });
    return {
      lines,
      required: isRequiredInTotal
    };
  }

}

const introspectMachine = machine => {
  const guards = new ItemMap({
    checkIfOptional: name => Boolean(machine.options?.guards?.[name])
  });
  const actions = new ItemMap({
    checkIfOptional: name => Boolean(machine.options?.actions?.[name])
  });
  const services = new ItemMap({
    checkIfOptional: name => Boolean(machine.options?.services?.[name])
  });
  const activities = new ItemMap({
    checkIfOptional: name => Boolean(machine.options?.activities?.[name])
  });
  const delays = new ItemMap({
    checkIfOptional: name => Boolean(machine.options?.delays?.[name])
  });
  const serviceSrcToIdMap = {};
  const nodeMaps = {};

  const addActionAndHandleChoose = (action, eventType, path) => {
    if (action.type === "xstate.choose" && Array.isArray(action.conds)) {
      action.conds.forEach(({
        cond,
        actions: condActions
      }) => {
        if (typeof cond === "string") {
          guards.addEventToItem(cond, eventType, path);
        }

        if (Array.isArray(condActions)) {
          condActions.forEach(condAction => {
            if (typeof condAction === "string") {
              actions.addEventToItem(condAction, eventType, path);
            }
          });
        } else if (typeof condActions === "string") {
          actions.addEventToItem(condActions, eventType, path);
        }
      });
    } else {
      actions.addEventToItem(action.type, eventType, path);
    }
  };

  const allStateNodes = machine.stateIds.map(id => machine.getStateNodeById(id));
  allStateNodes?.forEach(node => {
    nodeMaps[node.id] = {
      sources: new Set(),
      children: new Set()
    };
  });
  allStateNodes?.forEach(node => {
    Object.values(node.states)?.forEach(childNode => {
      nodeMaps[node.id].children.add(childNode.id);
    }); // TODO - make activities pick up the events
    // that led to them

    node.activities?.forEach(activity => {
      if (activity.type && activity.type !== "xstate.invoke") {
        activities.addItem(activity.type, node.path);
      }
    });
    node.after?.forEach(({
      delay
    }) => {
      if (typeof delay === "string") {
        delays.addItem(delay, node.path);
      }
    });
    node.invoke?.forEach(service => {
      const serviceSrc = getServiceSrc(service);
      if (typeof serviceSrc !== "string" || serviceSrc === machineExtractor.INLINE_IMPLEMENTATION_TYPE) return;
      services.addItem(serviceSrc, node.path);

      if (!serviceSrcToIdMap[serviceSrc]) {
        serviceSrcToIdMap[serviceSrc] = new Set();
      }

      serviceSrcToIdMap[serviceSrc].add(service.id);
    });
    node.transitions?.forEach(transition => {
      transition.target?.forEach(targetNode => {
        nodeMaps[targetNode.id].sources.add(transition.eventType);
      });

      if (transition.cond && transition.cond.name) {
        if (transition.cond.name !== "cond") {
          guards.addEventToItem(transition.cond.name, transition.eventType, node.path);
        }
      }

      transition.target?.forEach(targetNode => {
        /** Pick up invokes */
        targetNode.invoke?.forEach(service => {
          const serviceSrc = getServiceSrc(service);
          if (typeof serviceSrc !== "string") return;
          services.addEventToItem(serviceSrc, transition.eventType, node.path);
        });
      });

      if (transition.actions) {
        transition.actions?.forEach(action => {
          addActionAndHandleChoose(action, transition.eventType, node.path);
          const actionInOptions = machine.options.actions?.[action.type];

          if (actionInOptions && typeof actionInOptions === "object") {
            addActionAndHandleChoose(actionInOptions, transition.eventType, node.path);
          }
        });
      }
    });
  });
  allStateNodes?.forEach(node => {
    const allActions = [];
    allActions.push(...node.onExit);
    allActions.push(...node.onEntry);
    allActions?.forEach(action => {
      if (!action.type.startsWith("xstate.")) {
        actions.addItem(action.type, node.path);
      }
    });
    node.onEntry?.forEach(action => {
      const sources = nodeMaps[node.id].sources;
      sources?.forEach(source => {
        addActionAndHandleChoose(action, source, node.path);
        const actionInOptions = machine.options.actions?.[action.type];

        if (actionInOptions && typeof actionInOptions === "object") {
          addActionAndHandleChoose(actionInOptions, source, node.path);
        }
      });
    });
  });
  const subState = makeSubStateFromNode(machine, machine, nodeMaps);
  return {
    states: Object.entries(nodeMaps).map(([stateId, state]) => {
      return {
        id: stateId,
        sources: state.sources
      };
    }),
    stateMatches: getMatchesStates(machine),
    subState,
    guards: guards.toDataShape(),
    actions: actions.toDataShape(),
    services: services.toDataShape(),
    activities: activities.toDataShape(),
    delays: delays.toDataShape(),
    serviceSrcToIdMap
  };
};

const getServiceSrc = invoke => {
  if (typeof invoke.src === "string") {
    return invoke.src;
  }

  return invoke.src.type;
};

const filterOutIgnoredMachines = parseResult => {
  return { ...parseResult,
    machines: parseResult.machines.filter(machine => !machine.getIsIgnored())
  };
};

const isCursorInPosition = (nodeSourceLocation, cursorPosition) => {
  if (!nodeSourceLocation) return;
  const isOnSameLine = nodeSourceLocation.start.line - 1 === cursorPosition.line;
  const isWithinChars = cursorPosition.character >= nodeSourceLocation.start.column && cursorPosition.character <= nodeSourceLocation.end.column;

  if (isOnSameLine) {
    return isWithinChars;
  }

  const isWithinLines = cursorPosition.line >= nodeSourceLocation.start.line - 1 && cursorPosition.line <= nodeSourceLocation.end.line;
  return isWithinLines;
};

const getRangeFromSourceLocation = location => {
  return {
    start: {
      character: location.start.column,
      line: location.start.line - 1
    },
    end: {
      character: location.end.column,
      line: location.end.line - 1
    }
  };
};

const getSetOfNames = arr => {
  const set = new Set();
  arr.forEach(elem => set.add(elem.name));
  return set;
};

/**
 * This function takes the AST of a parsed machine (the MachineParseResult)
 * and returns a map of all of its inline implementations (ImplementationsMetadata).
 *
 * Each inline implementation is stored by a hash (its inlineImplemenationId)
 * and stores the raw text of its node.
 */

const getInlineImplementations = (parseResult, fileText) => {
  const allGuards =
  /**
   * We don't ask for 'named' implementations here,
   * since they're not declared inline
   */
  parseResult?.getAllConds(["inline", "identifier", "unknown"]) || [];
  const allServices = parseResult?.getAllServices(["inline", "identifier", "unknown"]) || [];
  const allActions = parseResult?.getAllActions(["inline", "identifier", "unknown"]) || [];
  const inlineImplementations = {
    actions: {},
    guards: {},
    services: {}
  };
  allGuards.forEach(guard => {
    inlineImplementations.guards[
    /**
     * The inlineDeclarationId comes from @xstate/machine-extractor,
     * and is a hash of the inline declaration's text.
     */
    guard.inlineDeclarationId] = {
      jsImplementation: getRawTextFromNode(fileText, guard.node)
    };
  });
  allActions.forEach(action => {
    inlineImplementations.actions[action.inlineDeclarationId] = {
      jsImplementation: getRawTextFromNode(fileText, action.node)
    };
  });
  allServices.forEach(service => {
    if (service.srcNode) {
      inlineImplementations.services[service.inlineDeclarationId] = {
        jsImplementation: getRawTextFromNode(fileText, service.srcNode)
      };
    }
  });
  return inlineImplementations;
};

const getRawTextFromNode = (text, node) => {
  return text.slice(node.start, node.end);
};

const getStateMatchesObjectSyntax = introspectionResult => {
  const getUnionForSubState = (subState, depth = 0) => {
    // Do not include sibling states in the union
    // if it's the root
    const states = depth === 0 ? [] : Object.keys(subState.states).map(state => JSON.stringify(state));
    const substatesWithChildren = Object.entries(subState.states).filter(([, value]) => {
      return Object.keys(value.states).length > 0;
    });

    if (substatesWithChildren.length > 0) {
      states.push(`{ ${substatesWithChildren.map(([state, value]) => {
        return `${JSON.stringify(state)}?: ${getUnionForSubState(value, depth + 1)};`;
      }).join("\n")} }`);
    }

    return `${states.join(" | ")}`;
  };

  return getUnionForSubState(introspectionResult.subState);
};

const getTypegenOutput = event => {
  return `
  // This file was automatically generated. Edits will be overwritten

  ${event.machines.filter(machine => machine.hasTypesNode).map((machine, index) => {
    try {
      const guardsToMock = {};
      machine.namedGuards.forEach(guard => {
        guardsToMock[guard] = () => false;
      });
      machine.config.context = {}; // xstate-ignore-next-line

      const createdMachine = xstate.createMachine(machine.config || {}, {
        guards: guardsToMock,
        actions: { ...machine.chooseActionsInOptions
        }
      });
      const introspectResult = introspectMachine(createdMachine);
      const actions = introspectResult.actions.lines.filter(line => !line.name.startsWith("xstate.")).filter(action => machine.namedActions.includes(action.name));
      const guards = introspectResult.guards.lines.filter(line => !line.name.startsWith("xstate.")).filter(elem => machine.namedGuards.includes(elem.name));
      const services = introspectResult.services.lines.filter(line => !line.name.startsWith("xstate.")).filter(invoke => machine.allServices.some(service => service.src === invoke.name));
      const delays = introspectResult.delays.lines.filter(line => !line.name.startsWith("xstate."));
      const requiredActions = actions.filter(action => !machine.actionsInOptions.includes(action.name)).map(action => JSON.stringify(action.name)).join(" | ");
      const requiredServices = services.filter(service => !machine.servicesInOptions.includes(service.name)).map(service => JSON.stringify(service.name)).join(" | ");
      const requiredGuards = guards.filter(guard => !machine.guardsInOptions.includes(guard.name)).map(guard => JSON.stringify(guard.name)).join(" | ");
      const requiredDelays = delays.filter(delay => !machine.delaysInOptions.includes(delay.name)).map(delay => JSON.stringify(delay.name)).join(" | ");
      const tags = machine.tags.map(tag => JSON.stringify(tag)).join(" | ");
      const matchesStates = introspectResult.stateMatches.map(candidate => JSON.stringify(candidate));
      const objectSyntax = getStateMatchesObjectSyntax(introspectResult);

      if (objectSyntax) {
        matchesStates.push(objectSyntax);
      }

      const internalEvents = collectInternalEvents([introspectResult.actions.lines, introspectResult.services.lines, introspectResult.guards.lines, introspectResult.delays.lines]);
      internalEvents["xstate.init"] = `'xstate.init': { type: 'xstate.init' };`;
      machine.allServices.forEach(service => {
        if (service.id) {
          internalEvents[`done.invoke.${service.id}`] = `${JSON.stringify(`done.invoke.${service.id}`)}: { type: ${JSON.stringify(`done.invoke.${service.id}`)}; data: unknown; __tip: "See the XState TS docs to learn how to strongly type this."; };`;
          internalEvents[`error.platform.${service.id}`] = `${JSON.stringify(`error.platform.${service.id}`)}: { type: ${JSON.stringify(`error.platform.${service.id}`)}; data: unknown; };`;
        }
      });
      return `export interface Typegen${index} {
          '@@xstate/typegen': true;
          eventsCausingActions: {
            ${displayEventsCausing(actions)}
          };
          internalEvents: {
            ${Object.values(internalEvents).join("\n")}
          };
          invokeSrcNameMap: {
            ${Object.keys(introspectResult.serviceSrcToIdMap).filter(src => {
        return machine.allServices.some(service => service.src === src);
      }).map(src => {
        const set = Array.from(introspectResult.serviceSrcToIdMap[src]);
        return `${JSON.stringify(src)}: ${set.map(item => JSON.stringify(`done.invoke.${item}`)).join(" | ")};`;
      }).join("\n")}
          }
          missingImplementations: {
            ${`actions: ${requiredActions || "never"};`}
            ${`services: ${requiredServices || "never"};`}
            ${`guards: ${requiredGuards || "never"};`}
            ${`delays: ${requiredDelays || "never"};`}
          }
          eventsCausingServices: {
            ${displayEventsCausing(services)}
          };
          eventsCausingGuards: {
            ${displayEventsCausing(guards)}
          };
          eventsCausingDelays: {
            ${displayEventsCausing(delays)}
          };
          matchesStates: ${matchesStates.join(" | ") || "undefined"};
          tags: ${tags || "never"};
        }`;
    } catch (e) {
      console.log(e);
    }

    return `export interface Typegen${index} {
        // An error occured, so we couldn't generate the TS
        '@@xstate/typegen': false;
      };`;
  }).join("\n")}
  `;
};

const collectInternalEvents = lineArrays => {
  const internalEvents = {};
  lineArrays.forEach(lines => {
    lines.forEach(line => {
      line.events.forEach(event => {
        if (event.startsWith("done.invoke")) {
          internalEvents[event] = `${JSON.stringify(event)}: { type: ${JSON.stringify(event)}; data: unknown; __tip: "See the XState TS docs to learn how to strongly type this."; };`;
        } else if (event.startsWith("xstate.") || event === "") {
          internalEvents[event] = `'${event}': { type: '${event}' };`;
        } else if (event.startsWith("error.platform")) {
          internalEvents[event] = `${JSON.stringify(event)}: { type: ${JSON.stringify(event)}; data: unknown; };`;
        }
      });
    });
  });
  return internalEvents;
};

const displayEventsCausing = lines => {
  return lines.map(line => {
    return `${JSON.stringify(line.name)}: ${unique(line.events.map(event => {
      return event;
    })).map(event => JSON.stringify(event)).join(" | ") ||
    /**
     * If no transitions go to this guard/service/action, it's guaranteed
     * to be caused by xstate.init.
     */
    "'xstate.init'"};`;
  }).join("\n");
};

const unique = array => {
  return Array.from(new Set(array));
};

const resolveUriToFilePrefix = uri => {
  if (!uri.startsWith("file://")) {
    return `file://${uri}`;
  }

  return uri;
};

const makeXStateUpdateEvent = (uri, machines) => {
  return {
    uri: resolveUriToFilePrefix(uri),
    machines: machines.map((machine, index) => {
      const config = machine.parseResult?.toConfig();
      return {
        config,
        index,
        typeNodeLoc: machine.parseResult?.ast?.definition?.tsTypes?.node.loc,
        definitionLoc: machine.parseResult?.ast?.definition?.node.loc,
        namedGuards: machine.parseResult?.getAllConds(["named"]).map(elem => elem.name) || [],
        namedActions: machine.parseResult?.getAllActions(["named"]).map(elem => elem.name) || [],
        allServices: machine.parseResult?.getAllServices(["named"]).map(elem => ({
          src: elem.src,
          id: elem.id
        })) || [],
        actionsInOptions: machine.parseResult?.ast?.options?.actions?.properties.map(property => property.key) || [],
        delaysInOptions: machine.parseResult?.ast?.options?.delays?.properties.map(property => property.key) || [],
        guardsInOptions: machine.parseResult?.ast?.options?.guards?.properties.map(property => property.key) || [],
        servicesInOptions: machine.parseResult?.ast?.options?.services?.properties.map(property => property.key) || [],
        tags: Array.from(new Set(machine.parseResult?.getAllStateNodes().flatMap(node => node.ast.tags?.map(tag => tag.value) || []) || [])),
        hasTypesNode: Boolean(machine.parseResult?.ast?.definition?.tsTypes?.node),
        chooseActionsInOptions: machine.parseResult?.getChooseActionsToAddToOptions() || {}
      };
    })
  };
};

const getDocumentValidationsResults = text => {
  return filterOutIgnoredMachines(machineExtractor.parseMachinesFromFile(text)).machines.map(parseResult => {
    if (!parseResult) {
      return {
        documentText: text
      };
    }

    const config = parseResult.toConfig();
    const chooseActionsForOptions = parseResult.getChooseActionsToAddToOptions();

    try {
      const machine = xstate.createMachine(config, {
        actions: chooseActionsForOptions
      });
      const introspectionResult = introspectMachine(machine);
      return {
        parseResult,
        machine,
        introspectionResult,
        documentText: text
      };
    } catch (e) {
      return {
        parseResult,
        documentText: text
      };
    }
  });
};

const writeToTypegenFile = async opts => {
  const prettierConfig = await prettier__namespace.resolveConfig(opts.filePath);
  const pathToSave = opts.filePath.slice(0, -path__namespace.extname(opts.filePath).length) + ".typegen.ts";

  if (opts.event.machines.some(machine => machine.hasTypesNode)) {
    const typegenOutput = getTypegenOutput(opts.event);
    await fs__namespace.writeFile(pathToSave, prettier__namespace.format(typegenOutput, { ...prettierConfig,
      parser: "typescript"
    }));
  } else {
    try {
      await fs__namespace.unlink(pathToSave);
    } catch (e) {
      if (e?.code === "ENOENT") {
        return;
      }

      throw e;
    }
  }
};

const doesTsTypesRequireUpdate = opts => {
  const currentText = getRawTextFromNode(opts.fileText, opts.node);
  const requiresUpdate = !currentText.includes(`./${opts.relativePath}.typegen`) || !currentText.includes(`Typegen${opts.machineIndex}`);
  return requiresUpdate;
};

const processFileEdits = (oldText, fileEdits) => {
  const fileEditsSortedByStart = [...fileEdits].sort((a, b) => b.start - a.start);
  let newText = oldText;

  for (const fileEdit of fileEditsSortedByStart) {
    newText = newText.substr(0, fileEdit.start) + fileEdit.newText + newText.substr(fileEdit.end);
  }

  return newText;
};

const prettierStartRegex = /^([^{]){1,}/;
const prettierEndRegex = /([^}]){1,}$/;
/**
 * We use these crazy @UNWRAP_START@ and @UNWRAP_END@ markers to
 * delineate the start and end of the text that we want to unwrap.
 *
 * We then use the regex to unwrap them later
 *
 * This is pretty quick and dirty - it works fairly robustly
 * but I'm open to offers to improve it.
 */

const UNWRAP_START = `@UNWRAP_START@`;
const UNWRAP_END = `@UNWRAP_END@`;

const markAsUnwrap = str => {
  return `${UNWRAP_START}${str}${UNWRAP_END}`;
};

const UNWRAPPER_REGEX = /"@UNWRAP_START@(.{1,})@UNWRAP_END@"/g;
const STATE_KEYS_TO_PRESERVE = ["context", "tsTypes", "schema", "meta", "data", "delimiter", "preserveActionOrder"];
const getNewMachineText = async ({
  text,
  fileName,
  newConfig,
  machine,
  implementations
}) => {
  const nodesToPreserve = STATE_KEYS_TO_PRESERVE.map(nodeKey => {
    const node = machine.ast.definition?.[nodeKey]?._valueNode || machine.ast.definition?.[nodeKey]?.node;
    return node ? `\n${nodeKey}: ${getRawTextFromNode(text, node).replace("\n", " ")},` : "";
  });
  const config = {};

  const getKeyStart = key => {
    const start = machine.ast.definition?.[key]?.node?.start;
    return start ?? 0;
  };

  Object.keys(newConfig).sort((a, b) => {
    return getKeyStart(a) - getKeyStart(b);
  }).forEach(key => {
    config[key] = newConfig[key];
  });
  const json = JSON.stringify(config, (key, value) => {
    if (key === "cond" && implementations?.guards?.[value]?.jsImplementation) {
      return markAsUnwrap(implementations?.guards?.[value]?.jsImplementation);
    }

    if (key === "src" && implementations?.services?.[value]?.jsImplementation) {
      return markAsUnwrap(implementations?.services?.[value]?.jsImplementation);
    }

    if (["actions", "entry", "exit"].includes(key)) {
      if (Array.isArray(value)) {
        return value.map(action => {
          if (implementations?.actions?.[action]?.jsImplementation) {
            return markAsUnwrap(implementations?.actions?.[action]?.jsImplementation);
          }

          return action;
        });
      }

      if (implementations?.actions?.[value]?.jsImplementation) {
        return markAsUnwrap(implementations?.actions?.[value]?.jsImplementation);
      }
    }

    return value;
  }, 2);
  const prettierConfig = await prettier__namespace.resolveConfig(fileName);
  let finalTextToInput = `{${nodesToPreserve.join("")}${json.slice(1)}`.replace(UNWRAPPER_REGEX, str => {
    return str // +1 and -1 for the quotes
    .slice(UNWRAP_START.length + 1, -UNWRAP_END.length - 1).replace(/\\n/g, "\n").replace(/\\"/g, '"').replace(/\\t/g, "\t");
  });

  try {
    const result = await prettier__namespace.format(`(${finalTextToInput})`, { ...prettierConfig,
      parser: "typescript"
    });
    finalTextToInput = result.replace(prettierStartRegex, "").replace(prettierEndRegex, "");
  } catch (e) {
    console.log(e);
  }

  return finalTextToInput;
};

exports.doesTsTypesRequireUpdate = doesTsTypesRequireUpdate;
exports.filterOutIgnoredMachines = filterOutIgnoredMachines;
exports.getDocumentValidationsResults = getDocumentValidationsResults;
exports.getInlineImplementations = getInlineImplementations;
exports.getMatchesStates = getMatchesStates;
exports.getNewMachineText = getNewMachineText;
exports.getRangeFromSourceLocation = getRangeFromSourceLocation;
exports.getRawTextFromNode = getRawTextFromNode;
exports.getRootNode = getRootNode;
exports.getSetOfNames = getSetOfNames;
exports.getStateMatchesObjectSyntax = getStateMatchesObjectSyntax;
exports.getTransitionsFromNode = getTransitionsFromNode;
exports.getTypegenOutput = getTypegenOutput;
exports.introspectMachine = introspectMachine;
exports.isCursorInPosition = isCursorInPosition;
exports.makeXStateUpdateEvent = makeXStateUpdateEvent;
exports.processFileEdits = processFileEdits;
exports.resolveUriToFilePrefix = resolveUriToFilePrefix;
exports.writeToTypegenFile = writeToTypegenFile;
