#!/usr/bin/env node
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var import_commander = require("commander");
var path = __toESM(require("path"));
var import_chokidar = require("chokidar");
var fs = __toESM(require("fs/promises"));
var import_machine_extractor = require("@xstate/machine-extractor");
var import_tools_shared = require("@xstate/tools-shared");
var import_package = require("../package.json");
const allSettled = (promises) => Promise.all(promises.map((promise) => promise.then((value) => ({ status: "fulfilled", value }), (reason) => ({ status: "rejected", reason }))));
const program = new import_commander.Command();
program.version(import_package.version);
const writeToFiles = async (uriArray) => {
  await Promise.all(uriArray.map(async (uri) => {
    try {
      const fileContents = await fs.readFile(uri, "utf8");
      const parseResult = (0, import_machine_extractor.parseMachinesFromFile)(fileContents);
      if (!parseResult.machines.length) {
        return;
      }
      const event = (0, import_tools_shared.makeXStateUpdateEvent)(uri, parseResult.machines.map((machine) => ({
        parseResult: machine
      })));
      const fileEdits = [];
      let machineIndex = 0;
      for (const machine of parseResult.machines) {
        if (machine.ast.definition?.tsTypes?.node) {
          const { name } = path.parse(uri);
          const requiresUpdate = (0, import_tools_shared.doesTsTypesRequireUpdate)({
            fileText: fileContents,
            machineIndex,
            node: machine.ast.definition.tsTypes.node,
            relativePath: name
          });
          if (requiresUpdate) {
            fileEdits.push({
              start: machine.ast.definition.tsTypes.node.start,
              end: machine.ast.definition.tsTypes.node.end,
              newText: `{} as import("./${name}.typegen").Typegen${machineIndex}`
            });
          }
          machineIndex++;
        }
      }
      if (fileEdits.length > 0) {
        const newFile = (0, import_tools_shared.processFileEdits)(fileContents, fileEdits);
        await fs.writeFile(uri, newFile);
      }
      await (0, import_tools_shared.writeToTypegenFile)({
        filePath: uri,
        event
      });
      console.log(`${uri} - success`);
    } catch (e) {
      if (e?.code === "BABEL_PARSER_SYNTAX_ERROR") {
        console.error(`${uri} - syntax error, skipping`);
      } else {
        console.error(`${uri} - error, `, e);
      }
      throw e;
    }
  }));
};
program.command("typegen").description("Generate TypeScript types from XState machines").argument("<files>", "The files to target, expressed as a glob pattern").option("-w, --watch", "Run the typegen in watch mode").action(async (filesPattern, opts) => {
  if (opts.watch) {
    const processFile = (path2) => {
      if (path2.endsWith(".typegen.ts")) {
        return;
      }
      writeToFiles([path2]).catch(() => {
      });
    };
    (0, import_chokidar.watch)(filesPattern, { awaitWriteFinish: true }).on("add", processFile).on("change", processFile);
  } else {
    const tasks = [];
    (0, import_chokidar.watch)(filesPattern, { persistent: false }).on("add", (path2) => {
      if (path2.endsWith(".typegen.ts")) {
        return;
      }
      tasks.push(writeToFiles([path2]));
    }).on("ready", async () => {
      const settled = await allSettled(tasks);
      if (settled.some((result) => result.status === "rejected")) {
        process.exit(1);
      }
      process.exit(0);
    });
  }
});
program.parse(process.argv);
