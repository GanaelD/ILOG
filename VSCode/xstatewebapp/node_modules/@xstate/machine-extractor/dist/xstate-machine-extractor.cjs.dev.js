'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@babel/core');
var actions = require('xstate/lib/actions');
var types = require('xstate/lib/types');

const INLINE_IMPLEMENTATION_TYPE = "_inline";

/**
 * Creates a parser, which can be run later on AST nodes
 * to work out if they match
 */
const createParser = params => {
  const matches = node => {
    return params.babelMatcher(node);
  };

  const parse = (node, context) => {
    if (!matches(node)) return undefined;
    return params.parseNode(node, context);
  };

  return {
    parse,
    matches
  };
};

/**
 * Used to declare when a type can be either one
 * thing or another. Each parser added must
 * return the same result
 */
const unionType = parsers => {
  const matches = node => {
    return parsers.some(parser => parser.matches(node));
  };

  const parse = (node, context) => {
    const possibleParsers = parsers.filter(parser => parser.matches(node));

    for (const parser of possibleParsers) {
      const result = parser.parse(node, context);
      if (result) return result;
    }
  };

  return {
    matches,
    parse
  };
};

/**
 * Allows you to wrap a parser and reformulate
 * the result at the end of it
 */
const wrapParserResult = (parser, changeResult) => {
  return {
    matches: parser.matches,
    parse: (node, context) => {
      const result = parser.parse(node, context);
      if (!result) return undefined;
      return changeResult(result, node, context);
    }
  };
};

/**
 * Finds a declarator in the same file which corresponds
 * to an identifier of the name you provide
 */

const findVariableDeclaratorWithName = (file, name) => {
  let declarator = null;
  core.traverse(file, {
    VariableDeclarator(path) {
      if (core.types.isIdentifier(path.node.id) && path.node.id.name === name) {
        declarator = path.node;
      }
    }

  });
  return declarator;
};
/**
 * Used for when you expect an identifier to be used
 * which references a variable declaration of a certain type
 */

const identifierReferencingVariableDeclaration = parser => {
  return createParser({
    babelMatcher: core.types.isIdentifier,
    parseNode: (node, context) => {
      const variableDeclarator = findVariableDeclaratorWithName(context.file, node.name);
      return parser.parse(variableDeclarator?.init, context);
    }
  });
};
/**
 * Finds a declarator in the same file which corresponds
 * to an identifier of the name you provide
 */

const findTSEnumDeclarationWithName = (file, name) => {
  let declarator = null;
  core.traverse(file, {
    TSEnumDeclaration(path) {
      if (core.types.isIdentifier(path.node.id) && path.node.id.name === name) {
        declarator = path.node;
      }
    }

  });
  return declarator;
};

const deepMemberExpressionToPath = memberExpression => {
  let currentLevel = memberExpression;
  const path = [];

  while (currentLevel) {
    if (core.types.isIdentifier(currentLevel.node)) {
      path.push(currentLevel.node.name);
    } else if (core.types.isMemberExpression(currentLevel.node) && core.types.isIdentifier(currentLevel.node.property)) {
      path.push(currentLevel.node.property.name);
    }

    currentLevel = currentLevel.child;
  }

  return path.reverse();
};

const deepMemberExpression = createParser({
  babelMatcher(node) {
    return core.types.isIdentifier(node) || core.types.isMemberExpression(node);
  },

  parseNode: (node, context) => {
    return {
      node,
      child: "object" in node ? deepMemberExpression.parse(node.object, context) : undefined
    };
  }
});
const objectExpressionWithDeepPath = (path, parser) => createParser({
  babelMatcher: core.types.isObjectExpression,
  parseNode: (node, context) => {
    let currentIndex = 0;
    let currentNode = node;

    while (path[currentIndex]) {
      const pathSection = path[currentIndex];
      const objectProperties = getPropertiesOfObjectExpression(currentNode, context);
      currentNode = objectProperties.find(property => property.key === pathSection && core.types.isObjectProperty(property.node))?.node?.value;
      currentIndex++;
    }

    return parser.parse(currentNode, context);
  }
});

const getRootIdentifierOfDeepMemberExpression = deepMemberExpression => {
  if (!deepMemberExpressionToPath) return undefined;

  if (core.types.isIdentifier(deepMemberExpression?.node)) {
    return deepMemberExpression?.node;
  }

  return getRootIdentifierOfDeepMemberExpression(deepMemberExpression?.child);
};

const memberExpressionReferencingObjectExpression = parser => createParser({
  babelMatcher: core.types.isMemberExpression,
  parseNode: (node, context) => {
    const result = deepMemberExpression.parse(node, context);
    const rootIdentifier = getRootIdentifierOfDeepMemberExpression(result);
    if (!result) return undefined;
    const path = deepMemberExpressionToPath(result);
    return identifierReferencingVariableDeclaration(objectExpressionWithDeepPath(path.slice(1), parser)).parse(rootIdentifier, context);
  }
});
const memberExpressionReferencingEnumMember = createParser({
  babelMatcher: core.types.isMemberExpression,
  parseNode: (node, context) => {
    const result = deepMemberExpression.parse(node, context);
    const rootIdentifier = getRootIdentifierOfDeepMemberExpression(result);
    if (!result) return undefined;
    const path = deepMemberExpressionToPath(result);
    const foundEnum = findTSEnumDeclarationWithName(context.file, rootIdentifier?.name);
    if (!foundEnum) return undefined;
    const targetEnumMember = path[1];
    const valueParser = unionType([wrapParserResult(parserFromBabelMatcher(core.types.isStringLiteral), node => node.value), wrapParserResult(parserFromBabelMatcher(core.types.isIdentifier), node => node.name)]);
    const memberIndex = foundEnum.members.findIndex(member => {
      const value = valueParser.parse(member.id, context);
      return value === targetEnumMember;
    });
    const member = foundEnum.members[memberIndex];

    if (!member) {
      return undefined;
    }

    if (member?.initializer) {
      return {
        node: member,
        value: unionType([wrapParserResult(parserFromBabelMatcher(core.types.isStringLiteral), node => node.value), wrapParserResult(parserFromBabelMatcher(core.types.isNumericLiteral), node => String(node.value))]).parse(member.initializer, context)
      };
    } else {
      return {
        node: member,
        value: String(memberIndex)
      };
    }
  }
});
const maybeIdentifierTo = parser => {
  return unionType([parser, identifierReferencingVariableDeclaration(parser), memberExpressionReferencingObjectExpression(parser)]);
};

const tsAsExpression = parser => {
  return createParser({
    babelMatcher: core.types.isTSAsExpression,
    parseNode: (node, context) => {
      if (parser.matches(node.expression)) {
        return parser.parse(node.expression, context);
      }
    }
  });
};
const maybeTsAsExpression = parser => {
  return unionType([parser, tsAsExpression(parser)]);
};

const StringLiteral = unionType([wrapParserResult(memberExpressionReferencingEnumMember, node => {
  return {
    node: node.node,
    value: node.value
  };
}), maybeTsAsExpression(maybeIdentifierTo(createParser({
  babelMatcher: core.types.isStringLiteral,
  parseNode: node => {
    return {
      value: node.value,
      node
    };
  }
})))]);
const NumericLiteral = maybeTsAsExpression(maybeIdentifierTo(createParser({
  babelMatcher: core.types.isNumericLiteral,
  parseNode: node => {
    return {
      value: node.value,
      node
    };
  }
})));
const BooleanLiteral = maybeTsAsExpression(maybeIdentifierTo(createParser({
  babelMatcher: core.types.isBooleanLiteral,
  parseNode: node => {
    return {
      value: node.value,
      node
    };
  }
})));
const AnyNode = createParser({
  babelMatcher: core.types.isNode,
  parseNode: node => ({
    node
  })
});
const Identifier = createParser({
  babelMatcher: core.types.isIdentifier,
  parseNode: node => ({
    node
  })
});
const TemplateLiteral = maybeTsAsExpression(maybeIdentifierTo(createParser({
  babelMatcher: core.types.isTemplateLiteral,
  parseNode: node => {
    let value = ""; // TODO - this might lead to weird issues if there is actually more than a single quasi there

    node.quasis.forEach(quasi => {
      value = `${value}${quasi.value.raw}`;
    });
    return {
      node,
      value
    };
  }
})));

const parserFromBabelMatcher = babelMatcher => createParser({
  babelMatcher,
  parseNode: node => node
});
/**
 * Useful for when something might, or might not,
 * be declared as an array
 */

const maybeArrayOf = parser => {
  const arrayParser = createParser({
    babelMatcher: core.types.isArrayExpression,
    parseNode: (node, context) => {
      const toReturn = [];
      node.elements.map(elem => {
        const result = parser.parse(elem, context);

        if (result && Array.isArray(result)) {
          toReturn.push(...result);
        } else if (result) {
          toReturn.push(result);
        }
      });
      return toReturn;
    }
  });
  const otherParser = wrapParserResult(parser, res => {
    if (Array.isArray(res)) {
      return res;
    }

    return [res];
  });
  return unionType([arrayParser, otherParser]);
};
/**
 * Used to declare that this node is declared
 * an array of something
 */

const arrayOf = parser => {
  return createParser({
    babelMatcher: core.types.isArrayExpression,
    parseNode: (node, context) => {
      const toReturn = [];
      node.elements.map(elem => {
        const result = parser.parse(elem, context);

        if (result) {
          toReturn.push(result);
        }
      });
      return toReturn;
    }
  });
};
const objectMethod = createParser({
  babelMatcher: core.types.isObjectMethod,
  parseNode: (node, context) => {
    return {
      node,
      key: wrapParserResult(Identifier, ({
        node
      }) => ({
        node: node,
        value: node.name
      })).parse(node.key, context)
    };
  }
});
const staticObjectProperty = keyParser => createParser({
  babelMatcher: node => {
    return core.types.isObjectProperty(node) && !node.computed;
  },
  parseNode: (node, context) => {
    return {
      node,
      key: keyParser.parse(node.key, context)
    };
  }
});
const spreadElement = parser => {
  return createParser({
    babelMatcher: core.types.isSpreadElement,
    parseNode: (node, context) => {
      const result = {
        node,
        argumentResult: parser.parse(node.argument, context)
      };
      return result;
    }
  });
};
const spreadElementReferencingIdentifier = parser => {
  return spreadElement(identifierReferencingVariableDeclaration(parser));
};
const dynamicObjectProperty = keyParser => createParser({
  babelMatcher: node => {
    return core.types.isObjectProperty(node) && node.computed;
  },
  parseNode: (node, context) => {
    return {
      node,
      key: keyParser.parse(node.key, context)
    };
  }
});
const staticPropertyWithKey = staticObjectProperty(unionType([createParser({
  babelMatcher: core.types.isIdentifier,
  parseNode: node => {
    return {
      node,
      value: node.name
    };
  }
}), StringLiteral, NumericLiteral]));
const dynamicPropertyWithKey = dynamicObjectProperty(maybeIdentifierTo(unionType([StringLiteral, NumericLiteral, TemplateLiteral])));
const propertyKey = unionType([objectMethod, staticPropertyWithKey, dynamicPropertyWithKey]);
/**
 * Utility function for grabbing the properties of
 * an object expression
 */

const getPropertiesOfObjectExpression = (node, context) => {
  const propertiesToReturn = [];
  node?.properties.forEach(property => {
    const propertiesToParse = [property];
    const spreadElementResult = spreadElementReferencingIdentifier(createParser({
      babelMatcher: core.types.isObjectExpression,
      parseNode: node => node
    })).parse(property, context);
    propertiesToParse.push(...(spreadElementResult?.argumentResult?.properties || []));
    propertiesToParse.forEach(property => {
      const result = propertyKey.parse(property, context);

      if (result && result?.key) {
        propertiesToReturn.push({
          key: `${result.key?.value}`,
          node: result.node,
          keyNode: result.key.node,
          property
        });
      }
    });
  });
  return propertiesToReturn;
};

/**
 * Used for declaring an object expression where the known keys
 * can be different things
 */
const objectTypeWithKnownKeys = parserObject => maybeTsAsExpression(maybeIdentifierTo(createParser({
  babelMatcher: core.types.isObjectExpression,
  parseNode: (node, context) => {
    const properties = getPropertiesOfObjectExpression(node, context);
    const parseObject = typeof parserObject === "function" ? parserObject() : parserObject;
    const toReturn = {
      node
    };
    properties?.forEach(property => {
      const key = property.key;
      const parser = parseObject[key];
      if (!parser) return;
      let result;

      if (core.types.isObjectMethod(property.node)) {
        result = parser.parse(property.node, context);
      } else if (core.types.isObjectProperty(property.node)) {
        result = parser.parse(property.node.value, context);

        if (result) {
          result._valueNode = property.node.value;
        }
      }

      toReturn[key] = result;
    });
    return toReturn;
  }
})));

/**
 * Used when you have a keyed object where all the
 * values are the same type, for instance `states` or
 * `on`
 */
const objectOf = parser => {
  return maybeIdentifierTo(createParser({
    babelMatcher: core.types.isObjectExpression,
    parseNode: (node, context) => {
      const properties = getPropertiesOfObjectExpression(node, context);
      const toReturn = {
        node,
        properties: []
      };
      properties.forEach(property => {
        let result;

        if (core.types.isObjectMethod(property.node)) {
          result = parser.parse(property.node, context);
        } else if (core.types.isObjectProperty(property.node)) {
          result = parser.parse(property.node.value, context);
        }

        if (result) {
          toReturn.properties.push({
            key: property.key,
            keyNode: property.keyNode,
            result,
            property: property.property
          });
        }
      });
      return toReturn;
    }
  }));
};
/**
 * Returns a parser for a named function and allows you to
 * parse its arguments
 */

const namedFunctionCall = (name, argument1Parser, argument2Parser) => {
  const namedFunctionParser = maybeTsAsExpression(maybeIdentifierTo(createParser({
    babelMatcher: core.types.isCallExpression,
    parseNode: node => {
      return node;
    }
  })));
  return {
    matches: node => {
      if (!namedFunctionParser.matches(node)) {
        return false;
      }

      if (!core.types.isIdentifier(node.callee)) {
        return false;
      }

      return node.callee.name === name;
    },
    parse: (node, context) => {
      return {
        node,
        argument1Result: argument1Parser.parse(node.arguments[0], context),
        argument2Result: argument2Parser?.parse(node.arguments[1], context)
      };
    }
  };
};
const isFunctionOrArrowFunctionExpression = node => {
  return core.types.isArrowFunctionExpression(node) || core.types.isFunctionExpression(node);
};
function hashedId(str) {
  return hash(str.replace(/\s/g, ""));
}
/**
 * Thanks, stack overflow!
 */

function hash(str) {
  return str.split("").reduce((prevHash, currVal) => (prevHash << 5) - prevHash + currVal.charCodeAt(0) | 0, 0).toString(32).substring(1, 10);
}

const CondAsFunctionExpression = createParser({
  babelMatcher: isFunctionOrArrowFunctionExpression,
  parseNode: (node, context) => {
    return {
      node,
      name: "",
      cond: () => {
        return false;
      },
      declarationType: "inline",
      inlineDeclarationId: context.getNodeHash(node)
    };
  }
});
const CondAsStringLiteral = createParser({
  babelMatcher: core.types.isStringLiteral,
  parseNode: (node, context) => {
    return {
      node,
      name: node.value,
      cond: node.value,
      declarationType: "named",
      inlineDeclarationId: context.getNodeHash(node)
    };
  }
});
const CondAsNode = createParser({
  babelMatcher: core.types.isNode,
  parseNode: (node, context) => {
    const id = context.getNodeHash(node);
    return {
      node,
      name: "",
      cond: id,
      declarationType: "unknown",
      inlineDeclarationId: id
    };
  }
});
const CondAsIdentifier = createParser({
  babelMatcher: core.types.isIdentifier,
  parseNode: (node, context) => {
    const id = context.getNodeHash(node);
    return {
      node,
      name: "",
      cond: id,
      declarationType: "identifier",
      inlineDeclarationId: id
    };
  }
});
const Cond = unionType([CondAsFunctionExpression, CondAsStringLiteral, CondAsIdentifier, CondAsNode]);

const AfterAction = wrapParserResult(namedFunctionCall("after", unionType([StringLiteral, NumericLiteral])), (result, node, context) => {
  return {
    node: result.node,
    action: actions.after(result.argument1Result?.value || ""),
    name: "",
    declarationType: "inline",
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const CancelAction = wrapParserResult(namedFunctionCall("cancel", AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.cancel(""),
    name: "",
    declarationType: "inline",
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const DoneAction = wrapParserResult(namedFunctionCall("done", AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.done(""),
    name: "",
    declarationType: "inline",
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const EscalateAction = wrapParserResult(namedFunctionCall("escalate", AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.escalate(""),
    name: "",
    declarationType: "inline",
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const LogAction = wrapParserResult(namedFunctionCall("log", AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.log(),
    name: "",
    declarationType: "inline",
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const PureAction = wrapParserResult(namedFunctionCall("pure", AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.pure(() => []),
    name: "",
    declarationType: "inline",
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const RaiseAction = wrapParserResult(namedFunctionCall("raise", AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.raise(""),
    name: "",
    declarationType: "inline",
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const RespondAction = wrapParserResult(namedFunctionCall("respond", AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.respond(""),
    name: "",
    declarationType: "inline",
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const SendParentAction = wrapParserResult(namedFunctionCall("sendParent", AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.sendParent(""),
    name: "",
    declarationType: "inline",
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const SendUpdateAction = wrapParserResult(namedFunctionCall("sendUpdate", AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.sendUpdate(),
    name: "",
    declarationType: "inline",
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const StartAction = wrapParserResult(namedFunctionCall("start", AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.start(""),
    name: "",
    declarationType: "inline",
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const StopAction = wrapParserResult(namedFunctionCall("stop", AnyNode), (result, node, context) => {
  return {
    node: result.node,
    action: actions.stop(""),
    name: "",
    declarationType: "inline",
    inlineDeclarationId: context.getNodeHash(node)
  };
});

const ActionAsIdentifier = maybeTsAsExpression(createParser({
  babelMatcher: core.types.isIdentifier,
  parseNode: (node, context) => {
    return {
      action: node.name,
      node,
      name: node.name,
      declarationType: "identifier",
      inlineDeclarationId: context.getNodeHash(node)
    };
  }
}));
const ActionAsFunctionExpression = maybeTsAsExpression(maybeIdentifierTo(createParser({
  babelMatcher: isFunctionOrArrowFunctionExpression,
  parseNode: (node, context) => {
    const action = function actions() {};

    const id = context.getNodeHash(node);

    action.toJSON = () => id;

    return {
      node,
      action,
      name: "",
      declarationType: "inline",
      inlineDeclarationId: id
    };
  }
})));
const ActionAsString = maybeTsAsExpression(maybeIdentifierTo(createParser({
  babelMatcher: core.types.isStringLiteral,
  parseNode: (node, context) => {
    return {
      action: node.value,
      node,
      name: node.value,
      declarationType: "named",
      inlineDeclarationId: context.getNodeHash(node)
    };
  }
})));
const ActionAsNode = createParser({
  babelMatcher: core.types.isNode,
  parseNode: (node, context) => {
    const id = context.getNodeHash(node);
    return {
      action: id,
      node,
      name: "",
      declarationType: "unknown",
      inlineDeclarationId: id
    };
  }
});
const ChooseFirstArg = arrayOf(objectTypeWithKnownKeys({
  cond: Cond,
  // Don't allow choose inside of choose for now,
  // too recursive
  // TODO - fix
  actions: maybeArrayOf(ActionAsString)
}));
const ChooseAction = wrapParserResult(namedFunctionCall("choose", ChooseFirstArg), (result, node, context) => {
  const conditions = [];
  result.argument1Result?.forEach(arg1Result => {
    const toPush = {
      condition: {
        actions: []
      },
      actionNodes: []
    };

    if (arg1Result.actions) {
      const actionResult = arg1Result.actions.map(action => action.action);

      if (actionResult.length === 1) {
        toPush.condition.actions = actionResult[0];
      } else {
        toPush.condition.actions = actionResult;
      }

      toPush.actionNodes = arg1Result.actions;
    }

    if (arg1Result.cond) {
      toPush.condition.cond = arg1Result.cond.cond;
      toPush.conditionNode = arg1Result.cond;
    }

    conditions.push(toPush);
  });
  return {
    node: node,
    action: actions.choose(conditions.map(condition => condition.condition)),
    chooseConditions: conditions,
    name: "",
    declarationType: "inline",
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const AssignFirstArgObject = createParser({
  babelMatcher: core.types.isObjectExpression,
  parseNode: (node, context) => {
    return {
      node,
      value: {}
    };
  }
});
const AssignFirstArgFunction = createParser({
  babelMatcher: isFunctionOrArrowFunctionExpression,
  parseNode: (node, context) => {
    const value = function anonymous() {
      return {};
    };

    value.toJSON = () => {
      return {};
    };

    return {
      node,
      value
    };
  }
});
const AssignFirstArg = unionType([AssignFirstArgObject, AssignFirstArgFunction]);
const AssignAction = wrapParserResult(namedFunctionCall("assign", AssignFirstArg), (result, node, context) => {
  const defaultAction = function anonymous() {
    return {};
  };

  defaultAction.toJSON = () => {
    return {};
  };

  return {
    node: result.node,
    action: actions.assign(result.argument1Result?.value || defaultAction),
    name: "",
    declarationType: "inline",
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const SendActionSecondArg = objectTypeWithKnownKeys({
  to: StringLiteral,
  delay: unionType([NumericLiteral, StringLiteral]),
  id: StringLiteral
});
const SendAction = wrapParserResult(namedFunctionCall("send", unionType([StringLiteral, AnyNode]), SendActionSecondArg), (result, node, context) => {
  return {
    node: result.node,
    name: "",
    action: actions.send(result.argument1Result?.value ?? (() => {
      return {
        type: "UNDEFINED"
      };
    }), {
      id: result.argument2Result?.id?.value,
      to: result.argument2Result?.to?.value,
      delay: result.argument2Result?.delay?.value
    }),
    declarationType: "inline",
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const ForwardToActionSecondArg = objectTypeWithKnownKeys({
  to: StringLiteral
});
const ForwardToAction = wrapParserResult(namedFunctionCall("forwardTo", StringLiteral, ForwardToActionSecondArg), (result, node, context) => {
  return {
    node: result.node,
    action: actions.forwardTo(result.argument1Result?.value || "", {
      to: result.argument2Result?.to?.value
    }),
    name: "",
    declarationType: "inline",
    inlineDeclarationId: context.getNodeHash(node)
  };
});
const NamedAction = unionType([ChooseAction, AssignAction, SendAction, ForwardToAction, AfterAction, CancelAction, DoneAction, EscalateAction, LogAction, PureAction, RaiseAction, RespondAction, SendUpdateAction, StartAction, StopAction, SendParentAction]);
const BasicAction = unionType([ActionAsFunctionExpression, ActionAsString, ActionAsIdentifier, ActionAsNode]);
maybeArrayOf(BasicAction);
const MaybeArrayOfActions = maybeArrayOf(unionType([NamedAction, BasicAction]));

const Context = AnyNode;

const HistoryAsString = createParser({
  babelMatcher: core.types.isStringLiteral,
  parseNode: node => {
    return {
      node,
      value: node.value
    };
  }
});
const HistoryAsBoolean = createParser({
  babelMatcher: core.types.isBooleanLiteral,
  parseNode: node => {
    return {
      node,
      value: node.value
    };
  }
});
const History = unionType([HistoryAsString, HistoryAsBoolean]);

const TransitionTarget = maybeArrayOf(unionType([StringLiteral, TemplateLiteral]));
const TransitionObject = objectTypeWithKnownKeys({
  target: TransitionTarget,
  actions: MaybeArrayOfActions,
  cond: Cond,
  description: unionType([StringLiteral, TemplateLiteral])
});
const TransitionConfigOrTargetLiteral = unionType([TransitionObject, wrapParserResult(TransitionTarget, targets => {
  return {
    target: targets,
    node: targets[0].node
  };
})]);
const MaybeTransitionArray = maybeArrayOf(TransitionConfigOrTargetLiteral);

const InvokeSrcFunctionExpression = maybeTsAsExpression(maybeIdentifierTo(createParser({
  babelMatcher: isFunctionOrArrowFunctionExpression,
  parseNode: (node, context) => {
    const id = context.getNodeHash(node);
    return {
      value: id,
      node,
      declarationType: "inline",
      inlineDeclarationId: id
    };
  }
})));
const InvokeSrcNode = createParser({
  babelMatcher: core.types.isNode,
  parseNode: (node, context) => {
    const id = context.getNodeHash(node);
    return {
      value: id,
      node,
      declarationType: "unknown",
      inlineDeclarationId: id
    };
  }
});
const InvokeSrcStringLiteral = createParser({
  babelMatcher: core.types.isStringLiteral,
  parseNode: (node, context) => ({
    value: node.value,
    node,
    declarationType: "named",
    inlineDeclarationId: context.getNodeHash(node)
  })
});
const InvokeSrcIdentifier = createParser({
  babelMatcher: core.types.isIdentifier,
  parseNode: (node, context) => {
    const id = context.getNodeHash(node);
    return {
      value: id,
      node,
      declarationType: "identifier",
      inlineDeclarationId: context.getNodeHash(node)
    };
  }
});
const InvokeSrc = unionType([InvokeSrcStringLiteral, InvokeSrcFunctionExpression, InvokeSrcIdentifier, InvokeSrcNode]);
const InvokeConfigObject = objectTypeWithKnownKeys({
  id: StringLiteral,
  src: InvokeSrc,
  onDone: MaybeTransitionArray,
  onError: MaybeTransitionArray,
  autoForward: BooleanLiteral,
  forward: BooleanLiteral
});
const Invoke = maybeArrayOf(InvokeConfigObject);

const MetaDescription = unionType([StringLiteral, TemplateLiteral]);
const StateMeta = objectTypeWithKnownKeys({
  description: MetaDescription
});

const Schema = objectTypeWithKnownKeys({
  context: AnyNode,
  events: AnyNode,
  services: AnyNode
});

const TsTypes = unionType([BooleanLiteral, AnyNode]);

const On = objectOf(MaybeTransitionArray);
const After = objectOf(MaybeTransitionArray);
const Tags = maybeArrayOf(StringLiteral);
/**
 * This is frustrating, but we need to keep this
 * up to date with the StateNode definition below.
 *
 * The reason? TS fails early when it hits a
 * recursive type definition, meaning our inference
 * falls out the window when StateNode tries to
 * reference itself
 */

const StateNodeObject = objectTypeWithKnownKeys(() => ({
  id: StringLiteral,
  initial: StringLiteral,
  type: StringLiteral,
  tsTypes: TsTypes,
  schema: Schema,
  history: History,
  delimiter: StringLiteral,
  entry: MaybeArrayOfActions,
  exit: MaybeArrayOfActions,
  onEntry: MaybeArrayOfActions,
  onExit: MaybeArrayOfActions,
  invoke: Invoke,
  always: MaybeTransitionArray,
  onDone: MaybeTransitionArray,
  after: After,
  on: On,
  tags: Tags,
  states: objectOf(StateNodeObject),
  meta: StateMeta,
  context: Context,
  data: AnyNode,
  preserveActionOrder: BooleanLiteral,
  parallel: BooleanLiteral,
  description: StringLiteral,
  version: AnyNode,
  key: StringLiteral,
  activities: AnyNode,
  parent: AnyNode,
  strict: BooleanLiteral,
  order: NumericLiteral
}));
const StateNode = StateNodeObject;

const MachineOptionsObject = objectTypeWithKnownKeys({
  actions: objectOf(unionType([ChooseAction, AnyNode])),
  services: objectOf(AnyNode),
  guards: objectOf(AnyNode),
  delays: objectOf(AnyNode),
  devTools: BooleanLiteral
});
const MachineOptions = maybeTsAsExpression(maybeIdentifierTo(MachineOptionsObject));

const TSTypeParameterInstantiation = parser => createParser({
  babelMatcher: core.types.isTSTypeParameterInstantiation,
  parseNode: (node, context) => {
    return {
      node,
      params: node.params.map(param => parser.parse(param, context))
    };
  }
});
const TSType = createParser({
  babelMatcher: core.types.isTSType,
  parseNode: node => {
    return {
      node
    };
  }
});
const AnyTypeParameterList = TSTypeParameterInstantiation(TSType);

const MachineCallExpression = createParser({
  babelMatcher: core.types.isCallExpression,
  parseNode: (node, context) => {
    if (core.types.isMemberExpression(node.callee) && core.types.isIdentifier(node.callee.property) && ["createMachine", "Machine"].includes(node.callee.property.name)) {
      return {
        callee: node.callee,
        calleeName: node.callee.property.name,
        definition: StateNode.parse(node.arguments[0], context),
        options: MachineOptions.parse(node.arguments[1], context),
        isMemberExpression: true,
        typeArguments: AnyTypeParameterList.parse(node.typeParameters, context),
        node
      };
    }

    if (core.types.isIdentifier(node.callee) && ["createMachine", "Machine"].includes(node.callee.name)) {
      return {
        callee: node.callee,
        calleeName: node.callee.name,
        definition: StateNode.parse(node.arguments[0], context),
        options: MachineOptions.parse(node.arguments[1], context),
        isMemberExpression: false,
        typeArguments: AnyTypeParameterList.parse(node.typeParameters, context),
        node
      };
    }
  }
});

const parseStateNode = (astResult, opts) => {
  const config = {};

  if (astResult?.id) {
    config.id = astResult.id.value;
  }

  if (astResult?.initial) {
    config.initial = astResult.initial.value;
  }

  if (astResult?.type) {
    config.type = astResult.type.value;
  }

  if (astResult.entry) {
    config.entry = getActionConfig(astResult.entry, opts);
  }

  if (astResult.onEntry) {
    config.onEntry = getActionConfig(astResult.onEntry, opts);
  }

  if (astResult.exit) {
    config.exit = getActionConfig(astResult.exit, opts);
  }

  if (astResult.onExit) {
    config.onExit = getActionConfig(astResult.onExit, opts);
  }

  if (astResult.tags) {
    const tags = astResult.tags.map(tag => tag.value);

    if (tags.length === 1) {
      config.tags = tags[0];
    } else {
      config.tags = tags;
    }
  }

  if (astResult.on) {
    config.on = {};
    astResult.on.properties.forEach(onProperty => {
      config.on[onProperty.key] = getTransitions(onProperty.result, opts);
    });
  }

  if (astResult.after) {
    config.after = {};
    astResult.after.properties.forEach(afterProperty => {
      config.after[afterProperty.key] = getTransitions(afterProperty.result, opts);
    });
  }

  if (astResult.history) {
    config.history = astResult.history.value;
  }

  if (astResult.states) {
    const states = {};
    astResult.states.properties.forEach(state => {
      states[state.key] = parseStateNode(state.result, opts);
    });
    config.states = states;
  }

  if (astResult.always) {
    config.always = getTransitions(astResult.always, opts);
  }

  if (astResult.meta?.description) {
    config.meta = {
      description: astResult.meta.description.value
    };
  }

  if (astResult.onDone) {
    config.onDone = getTransitions(astResult.onDone, opts);
  }

  if (astResult.description) {
    config.description = astResult.description.value;
  }

  if (astResult.invoke) {
    const invokes = [];
    astResult.invoke.forEach(invoke => {
      if (!invoke.src) return;
      let src;

      if (opts?.hashInlineImplementations) {
        src = invoke.src.declarationType === "named" ? invoke.src.value : invoke.src.inlineDeclarationId;
      } else {
        src = invoke.src.value;
      }

      const toPush = {
        src
      };

      if (invoke.id) {
        toPush.id = invoke.id.value;
      }

      if (invoke.autoForward) {
        toPush.autoForward = invoke.autoForward.value;
      }

      if (invoke.forward) {
        toPush.forward = invoke.forward.value;
      }

      if (invoke.onDone) {
        toPush.onDone = getTransitions(invoke.onDone, opts);
      }

      if (invoke.onError) {
        toPush.onError = getTransitions(invoke.onError, opts);
      }

      invokes.push(toPush);
    });

    if (invokes.length === 1) {
      config.invoke = invokes[0];
    } else {
      config.invoke = invokes;
    }
  }

  return config;
};

const toMachineConfig = (result, opts) => {
  if (!result?.definition) return undefined;
  return parseStateNode(result?.definition, opts);
};
const getActionConfig = (astActions, opts) => {
  const actions = [];
  astActions?.forEach(action => {
    if (opts?.hashInlineImplementations && action.declarationType !== "named") {
      actions.push({
        type: action.inlineDeclarationId
      });
    } else {
      actions.push(action.action);
    }
  });

  if (actions.length === 1) {
    return actions[0];
  }

  return actions;
};
const getTransitions = (astTransitions, opts) => {
  const transitions = [];
  astTransitions?.forEach(transition => {
    const toPush = {};

    if (transition?.target && transition?.target?.length > 0) {
      if (transition.target.length === 1) {
        toPush.target = transition?.target[0].value;
      } else {
        toPush.target = transition?.target.map(target => target.value);
      }
    }

    if (transition?.cond) {
      if (opts?.hashInlineImplementations && transition.cond.declarationType !== "named") {
        toPush.cond = transition.cond.inlineDeclarationId;
      } else {
        toPush.cond = transition?.cond.cond;
      }
    }

    if (transition?.actions) {
      toPush.actions = getActionConfig(transition.actions, opts);
    }

    if (transition?.description) {
      toPush.description = transition?.description.value;
    }

    transitions.push(toPush);
  });

  if (transitions.length === 1) {
    return transitions[0];
  }

  return transitions;
};

class RecordOfArrays {
  map = {};
  add = (key, value) => {
    if (!this.map[key]) {
      this.map[key] = [];
    }

    this.map[key].push(value);
  };
  toObject = () => this.map;
}

/**
 * Matches '@xstate-layout awdh123jbawdjhbawd'
 */
const layoutRegex = /@xstate-layout [^\s]{1,}/;

const getLayoutString = commentString => {
  const result = commentString.match(layoutRegex)?.[0];
  return result?.slice(`@xstate-layout `.length);
};
/**
 * Gives some helpers to the user of the lib
 */


class MachineParseResult {
  constructor(props) {
    this.ast = props.ast;
    this.fileComments = props.fileComments;
    this.scope = props.scope;
    this.stateNodes = this._getAllStateNodes();
  }

  _getAllStateNodes = () => {
    if (!this.ast?.definition) return [];
    const nodes = [];

    const getSubNodes = (definition, path) => {
      if (definition) {
        nodes.push({
          ast: definition,
          path
        });
      }

      definition?.states?.properties.forEach(stateNode => {
        getSubNodes(stateNode.result, [...path, stateNode.key]);
      });
    };

    getSubNodes(this.ast?.definition, []);
    return nodes;
  };
  getIsIgnored = () => {
    if (!this.ast?.callee?.loc) return false;
    const isIgnored = this.fileComments.some(comment => {
      if (comment.type !== "xstate-ignore-next-line") return false;
      return comment.node.loc.end.line === this.ast.callee.loc.start.line - 1;
    });
    return isIgnored;
  };
  getChooseActionsToAddToOptions = () => {
    const actions$1 = {};
    const chooseActions = this.getChooseActionsInOptions();
    chooseActions.forEach(action => {
      if (action.node.chooseConditions) {
        actions$1[action.node.name] = actions.choose(action.node.chooseConditions.map(chooseCondition => ({
          actions: chooseCondition.actionNodes.map(action => action.name),
          cond: chooseCondition.condition.cond
        })));
      }
    });
    return actions$1;
  };
  getChooseActionsInOptions = () => {
    const chooseActions = [];
    const allActionsInConfig = this.getAllActionsInConfig();
    this.ast.options?.actions?.properties.forEach(actionProperty => {
      if (actionProperty.result && "action" in actionProperty.result && actionProperty.result.chooseConditions) {
        const actionInConfig = allActionsInConfig.find(a => a.node.name === actionProperty.key);

        if (actionInConfig) {
          chooseActions.push({
            node: Object.assign(actionProperty.result, {
              /**
               * Give it the name of the action in the config
               */
              name: actionInConfig.node.name
            }),
            statePath: actionInConfig.statePath
          });
        }
      }
    });
    return chooseActions;
  };
  /**
   * Returns the raw value of a comment marked with @xstate-layout.
   *
   * For instance: '@xstate-layout 1234' will return '1234'
   */

  getLayoutComment = () => {
    if (!this.ast?.callee?.loc) return undefined;
    const layoutComment = this.fileComments.find(comment => {
      if (comment.type !== "xstate-layout") return false;
      return comment.node.loc.end.line === this.ast.callee.loc.start.line - 1;
    });
    if (!layoutComment) return undefined;
    const comment = layoutComment?.node.value || "";
    const value = getLayoutString(comment);
    if (!value) return undefined;
    return {
      comment: layoutComment,
      value
    };
  };
  getTransitions = () => {
    const targets = [];
    this.stateNodes.forEach(stateNode => {
      stateNode.ast.on?.properties.forEach(on => {
        on.result.forEach(transition => {
          targets.push({
            config: transition,
            fromPath: stateNode.path
          });
        });
      });
      stateNode.ast.after?.properties.forEach(after => {
        after.result.forEach(transition => {
          targets.push({
            config: transition,
            fromPath: stateNode.path
          });
        });
      });
      stateNode.ast.onDone?.forEach(transition => {
        targets.push({
          config: transition,
          fromPath: stateNode.path
        });
      });
      stateNode.ast.invoke?.forEach(invoke => {
        invoke.onDone?.forEach(transition => {
          targets.push({
            config: transition,
            fromPath: stateNode.path
          });
        });
        invoke.onError?.forEach(transition => {
          targets.push({
            config: transition,
            fromPath: stateNode.path
          });
        });
      });
      stateNode.ast.always?.forEach(transition => {
        targets.push({
          config: transition,
          fromPath: stateNode.path
        });
      });
    });
    return targets;
  };
  getTransitionTargets = () => {
    return this.getTransitions().map(transition => ({
      target: transition.config?.target,
      fromPath: transition.fromPath
    })).filter(transition => Boolean(transition.target));
  };
  getStateNodeByPath = path => {
    return this.stateNodes.find(node => {
      return node.path.join("") === path.join("");
    });
  };
  getAllStateNodes = () => this.stateNodes;
  toConfig = opts => {
    return toMachineConfig(this.ast, opts);
  };
  getAllConds = (declarationTypes = ["identifier", "inline", "unknown", "named"]) => {
    const conds = [];
    this.getTransitions().forEach(transition => {
      if (transition.config.cond?.declarationType && declarationTypes.includes(transition.config.cond?.declarationType)) {
        conds.push({
          name: transition.config.cond.name,
          node: transition.config.cond.node,
          cond: transition.config.cond.cond,
          statePath: transition.fromPath,
          inlineDeclarationId: transition.config.cond.inlineDeclarationId
        });
      }
    });
    this.getChooseActionsInOptions().concat(this.getAllActionsInConfig()).forEach(action => {
      action.node.chooseConditions?.forEach(chooseCondition => {
        if (chooseCondition.conditionNode?.declarationType && declarationTypes.includes(chooseCondition.conditionNode?.declarationType)) {
          conds.push({
            name: chooseCondition.conditionNode.name,
            node: chooseCondition.conditionNode.node,
            cond: chooseCondition.conditionNode.cond,
            statePath: action.statePath,
            inlineDeclarationId: chooseCondition.conditionNode.inlineDeclarationId
          });
        }
      });
    });
    return conds;
  };
  getAllActionsInConfig = () => {
    const actions = [];

    const addAction = (action, statePath) => {
      actions.push({
        node: action,
        statePath
      });
      action.chooseConditions?.forEach(chooseCondition => {
        chooseCondition.actionNodes.forEach(action => {
          addAction(action, statePath);
        });
      });
    };

    this.getTransitions().forEach(transition => {
      transition.config?.actions?.forEach(action => addAction(action, transition.fromPath));
    });
    this.getAllStateNodes().forEach(node => {
      node.ast.entry?.forEach(action => {
        addAction(action, node.path);
      });
      node.ast.onEntry?.forEach(action => {
        addAction(action, node.path);
      });
      node.ast.exit?.forEach(action => {
        addAction(action, node.path);
      });
      node.ast.onExit?.forEach(action => {
        addAction(action, node.path);
      });
    });
    return actions;
  };
  getAllActions = (declarationTypes = ["identifier", "inline", "unknown", "named"]) => {
    const actions = [];

    const addActionIfHasName = (action, statePath) => {
      if (action && declarationTypes.includes(action.declarationType)) {
        actions.push({
          name: action.name,
          node: action.node,
          action: action.action,
          statePath,
          chooseConditions: action.chooseConditions,
          inlineDeclarationId: action.inlineDeclarationId
        });
      }
    };

    this.getAllActionsInConfig().forEach(action => {
      addActionIfHasName(action.node, action.statePath);
    });
    this.getChooseActionsInOptions().forEach(action => {
      action.node.chooseConditions?.forEach(chooseCondition => {
        chooseCondition.actionNodes.forEach(chooseAction => {
          addActionIfHasName(chooseAction, action.statePath);
        });
      });
    });
    return actions;
  };
  getAllServices = (declarationTypes = ["identifier", "inline", "unknown", "named"]) => {
    const services = [];
    this.stateNodes.map(stateNode => {
      stateNode.ast.invoke?.forEach(invoke => {
        const invokeSrc = typeof invoke.src?.value === "string" ? invoke.src.value : undefined;

        if (invoke.src?.declarationType && declarationTypes.includes(invoke.src?.declarationType)) {
          services.push({
            src: invokeSrc ?? invoke.src?.inlineDeclarationId,
            id: invoke.id?.value,
            node: invoke.node,
            statePath: stateNode.path,
            srcNode: invoke.src?.node,
            inlineDeclarationId: invoke.src?.inlineDeclarationId
          });
        }
      });
    });
    return services;
  };
  getAllNamedDelays = () => {
    const delays = new RecordOfArrays();
    this.stateNodes.map(stateNode => {
      stateNode.ast.after?.properties.forEach(property => {
        if (core.types.isIdentifier(property.keyNode)) {
          const key = property.key;
          delays.add(key, {
            node: property.keyNode,
            name: key,
            statePath: stateNode.path
          });
        }
      });
    });
    return delays.toObject();
  };
  getActionImplementation = name => {
    const node = this.ast?.options?.actions?.properties.find(property => {
      return property.key === name;
    });
    return node;
  };
  getServiceImplementation = name => {
    const node = this.ast?.options?.services?.properties.find(property => {
      return property.key === name;
    });
    return node;
  };
  getGuardImplementation = name => {
    const node = this.ast?.options?.guards?.properties.find(property => {
      return property.key === name;
    });
    return node;
  };
}

const parseMachinesFromFile = fileContents => {
  if (!fileContents.includes("createMachine") && !fileContents.includes("Machine")) {
    return {
      machines: [],
      comments: [],
      file: undefined
    };
  }

  const parseResult = core.parse(fileContents, {
    sourceType: "module",
    configFile: false,
    babelrc: false,
    parserOpts: {
      plugins: ["typescript", "jsx", ["decorators", {
        decoratorsBeforeExport: false
      }]]
    }
  });
  let result = {
    machines: [],
    comments: [],
    file: parseResult
  };
  parseResult.comments?.forEach(comment => {
    if (comment.value.includes("xstate-ignore-next-line")) {
      result.comments.push({
        node: comment,
        type: "xstate-ignore-next-line"
      });
    } else if (comment.value.includes("@xstate-layout")) {
      result.comments.push({
        node: comment,
        type: "xstate-layout"
      });
    }
  });

  const getNodeHash = node => {
    const fileText = fileContents.substring(node.start, node.end);
    return hashedId(fileText);
  };

  core.traverse(parseResult, {
    CallExpression(path) {
      const ast = MachineCallExpression.parse(path.node, {
        file: parseResult,
        getNodeHash: getNodeHash
      });

      if (ast) {
        result.machines.push(new MachineParseResult({
          ast,
          fileComments: result.comments,
          scope: path.scope
        }));
      }
    }

  });
  return result;
};

const groupByUniqueName = arr => {
  const record = new RecordOfArrays();
  arr.forEach(elem => {
    record.add(elem.name, elem);
  });
  return record.toObject();
};

exports.INLINE_IMPLEMENTATION_TYPE = INLINE_IMPLEMENTATION_TYPE;
exports.MachineParseResult = MachineParseResult;
exports.StateNode = StateNode;
exports.arrayOf = arrayOf;
exports.dynamicObjectProperty = dynamicObjectProperty;
exports.getPropertiesOfObjectExpression = getPropertiesOfObjectExpression;
exports.groupByUniqueName = groupByUniqueName;
exports.hashedId = hashedId;
exports.isFunctionOrArrowFunctionExpression = isFunctionOrArrowFunctionExpression;
exports.maybeArrayOf = maybeArrayOf;
exports.namedFunctionCall = namedFunctionCall;
exports.objectMethod = objectMethod;
exports.objectOf = objectOf;
exports.objectTypeWithKnownKeys = objectTypeWithKnownKeys;
exports.parseMachinesFromFile = parseMachinesFromFile;
exports.parserFromBabelMatcher = parserFromBabelMatcher;
exports.spreadElement = spreadElement;
exports.spreadElementReferencingIdentifier = spreadElementReferencingIdentifier;
exports.staticObjectProperty = staticObjectProperty;
Object.keys(types).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return types[k];
    }
  });
});
