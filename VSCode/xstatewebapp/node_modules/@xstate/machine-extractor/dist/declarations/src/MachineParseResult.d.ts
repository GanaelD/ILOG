import { Action, Condition } from "xstate";
import { types as t, NodePath } from "@babel/core";
import { TMachineCallExpression } from "./machineCallExpression";
import { StateNodeReturn } from "./stateNode";
import { ToMachineConfigParseOptions } from "./toMachineConfig";
import { StringLiteralNode, Comment } from "./types";
import { TransitionConfigNode } from "./transitions";
import { ActionNode, ParsedChooseCondition } from "./actions";
import { DeclarationType } from ".";
export interface MachineParseResultStateNode {
    path: string[];
    ast: StateNodeReturn;
}
/**
 * Gives some helpers to the user of the lib
 */
export declare class MachineParseResult {
    ast: TMachineCallExpression;
    fileComments: Comment[];
    private stateNodes;
    scope: NodePath["scope"];
    constructor(props: {
        ast: TMachineCallExpression;
        fileComments: Comment[];
        scope: NodePath["scope"];
    });
    private _getAllStateNodes;
    getIsIgnored: () => boolean;
    getChooseActionsToAddToOptions: () => {
        [x: string]: import("xstate").ActionObject<any, any> | ((context: any, event: any, meta: import("xstate").ActionMeta<any, any, any>) => void) | undefined;
    };
    private getChooseActionsInOptions;
    /**
     * Returns the raw value of a comment marked with @xstate-layout.
     *
     * For instance: '@xstate-layout 1234' will return '1234'
     */
    getLayoutComment: () => {
        value: string;
        comment: Comment;
    } | undefined;
    getTransitions: () => {
        config: TransitionConfigNode;
        fromPath: string[];
    }[];
    getTransitionTargets: () => {
        fromPath: string[];
        target: StringLiteralNode[];
    }[];
    getStateNodeByPath: (path: string[]) => MachineParseResultStateNode | undefined;
    getAllStateNodes: () => MachineParseResultStateNode[];
    toConfig: (opts?: ToMachineConfigParseOptions | undefined) => import("xstate").MachineConfig<any, any, any, import("xstate").BaseActionObject, import("xstate").ServiceMap, import("xstate").TypegenDisabled> | undefined;
    getAllConds: (declarationTypes?: DeclarationType[]) => {
        node: t.Node;
        cond: Condition<any, any>;
        statePath: string[];
        name: string;
        inlineDeclarationId: string;
    }[];
    private getAllActionsInConfig;
    getAllActions: (declarationTypes?: DeclarationType[]) => {
        node: t.Node;
        action: Action<any, any>;
        statePath: string[];
        chooseConditions?: ParsedChooseCondition[] | undefined;
        name: string;
        inlineDeclarationId: string;
    }[];
    getAllServices: (declarationTypes?: DeclarationType[]) => {
        node: t.Node;
        src: string;
        id: string | undefined;
        statePath: string[];
        srcNode: t.Node | undefined;
        inlineDeclarationId: string;
    }[];
    getAllNamedDelays: () => Record<string, {
        node: t.Node;
        name: string;
        statePath: string[];
    }[]>;
    getActionImplementation: (name: string) => {
        keyNode: t.Node;
        key: string;
        result: ActionNode | {
            node: t.Node;
        };
        property: t.ObjectMethod | t.ObjectProperty | t.SpreadElement;
    } | undefined;
    getServiceImplementation: (name: string) => {
        keyNode: t.Node;
        key: string;
        result: {
            node: t.Node;
        };
        property: t.ObjectMethod | t.ObjectProperty | t.SpreadElement;
    } | undefined;
    getGuardImplementation: (name: string) => {
        keyNode: t.Node;
        key: string;
        result: {
            node: t.Node;
        };
        property: t.ObjectMethod | t.ObjectProperty | t.SpreadElement;
    } | undefined;
}
